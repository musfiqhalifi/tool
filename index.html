<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow">
    <title>Text Encryption/Decryption XChaCha20-Poly1305 with PBKDF2</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tweetnacl/1.0.3/nacl.min.js"></script>
    <style>
        textarea { width: 98%; }
        input { width: 98%;}
    </style>
</head>
<body>
    <hr>
    <h1>Text Encryption/Decryption XChaCha20-Poly1305 with PBKDF2</h1>
    <hr>
    <h2>Enkripsi</h2>
    <form id="encryptForm">
        <select id="inputFormatEncrypt">
            <option value="utf8">UTF-8</option>
            <option value="hex">Hex</option>
            <option value="base32">Base32</option>
            <option value="base64">Base64</option>
        </select>
        <button type="button" onclick="clearText('inputText', 'encryptCounter', 'encryptStatus', 'outputEncryptCounter')">Clear</button>
        <br>
        <textarea id="inputText" rows="5" placeholder="Plaintext" oninput="updateCounter('encryptCounter', this.value, document.getElementById('inputFormatEncrypt').value)"></textarea>
        <div id="encryptCounter" class="counter">Karakter: 0 | Ukuran: 0 Bit</div>
        <br>
        <input type="password" id="password" placeholder="Password (UTF-8)" value="a">
        <br>
        <div id="passwordEntropy"></div>
        <div id="passwordStrength" class="strength-status"></div>
        <button type="button" onclick="togglePassword('password')">Show/Hide</button>
        <button type="button" onclick="generateStrongPassword('password', 64)">Generate</button>
        <br>
        <br>
        <input type="number" id="iterations" placeholder="Iterasi (Dec)" min="1" value="1" required>
        <br>
        <button type="button" onclick="generateRandomNumber()">Generate</button>
        <br>
        <br>
        <button type="submit">Enkripsi</button>
    </form>
    <h3>Status Enkripsi</h3>
    <div id="encryptStatus" class="status"></div>
    <h3>Output Enkripsi</h3>
    <select id="outputFormatEncrypt">
        <option value="hex">Hex</option>
        <option value="base32">Base32</option>
        <option value="base64">Base64</option>
    </select>
    <br>
    <textarea id="outputEncrypt" rows="5" placeholder="Ciphertext" readonly></textarea>
    <div id="outputEncryptCounter" class="counter">Karakter: 0 | Ukuran: 0 Bit</div>
    <button type="button" onclick="copyToClipboard('outputEncrypt')">Copy</button>
    <hr>
    <h2>Dekripsi</h2>
    <form id="decryptForm">
        <select id="inputFormatDecrypt">
            <option value="hex">Hex</option>
            <option value="base32">Base32</option>
            <option value="base64">Base64</option>
        </select>
        <button type="button" onclick="clearText('inputCiphertext', 'decryptCounter', 'decryptStatus', 'outputDecryptCounter')">Clear</button>
        <br>
        <textarea id="inputCiphertext" rows="5" placeholder="Ciphertext" oninput="updateCounter('decryptCounter', this.value, document.getElementById('inputFormatDecrypt').value)"></textarea>
        <div id="decryptCounter" class="counter">Karakter: 0 | Ukuran: 0 Bit</div>
        <br>
        <input type="password" id="decPassword" placeholder="Password (UTF-8)" value="a">
        <br>
        <button type="button" onclick="togglePassword('decPassword')">Show/Hide</button>
        <br>
        <br>
        <button type="submit">Dekripsi</button>
    </form>
    <h3>Status Dekripsi</h3>
    <div id="decryptStatus" class="status"></div>
    <h3>Output Dekripsi</h3>
    <select id="outputFormatDecrypt">
        <option value="utf8">UTF-8</option>
        <option value="hex">Hex</option>
        <option value="base32">Base32</option>
        <option value="base64">Base64</option>
    </select>
    <br>
    <textarea id="outputDecrypt" rows="5" placeholder="Plaintext" readonly></textarea>
    <div id="outputDecryptCounter" class="counter">Karakter: 0 | Ukuran: 0 Bit</div>
    <button type="button" onclick="copyToClipboard('outputDecrypt')">Copy</button>
    <hr>

    <script>
    function generateRandom(inputId, length) {
        const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@#$_&-+()/*:;!?~`|•√π÷×¶∆£¢€¥^°={}\%©®™✓[]№—_–·±[<{]}>★†‡„“”«»¡¿♪ΩΠμ§′∞≠≈‰℅";
        let password = "";
        const array = new Uint32Array(length);

        // Menggunakan crypto.getRandomValues untuk mendapatkan angka acak
        window.crypto.getRandomValues(array);

        for (let i = 0; i < length; i++) {
            const randomIndex = array[i] % charset.length; // Mengambil index yang valid
            password += charset[randomIndex];
        }

        document.getElementById(inputId).value = password;
    }      

    function generateStrongPassword(inputId, length) {
        const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@#$_&-+()/*:;!?~`|•√π÷×¶∆£¢€¥^°={}\%©®™✓[]№—_–·±[<{]}>★†‡„“”«»¡¿♪ΩΠμ§′∞≠≈‰℅";
        let password = "";
        const array = new Uint32Array(length);

        // Menggunakan crypto.getRandomValues untuk mendapatkan angka acak
        window.crypto.getRandomValues(array);

        for (let i = 0; i < length; i++) {
            const randomIndex = array[i] % charset.length; // Mengambil index yang valid
            password += charset[randomIndex];
        }

        document.getElementById(inputId).value = password;
    
    const strength = checkPasswordStrength(password);
    updatePasswordStrengthMeter(strength);
    
    const entropy = calculateEntropy(password);
    document.getElementById('passwordEntropy').textContent = `Entropi: ${entropy.toFixed(0)} bit`;
    }

    function generateRandomNumber() {
        const array = new Uint32Array(1);
    
        // Menggunakan crypto.getRandomValues untuk mendapatkan angka acak
        window.crypto.getRandomValues(array);

        const randomNumber = (array[0] % 9999999) + 1; // Mengambil angka dalam rentang yang diinginkan
        document.getElementById('iterations').value = randomNumber;
    }

async function pbkdf2(password, salt, iterations, keyLength) {
    return crypto.subtle.importKey('raw', new TextEncoder().encode(password), 'PBKDF2', false, ['deriveBits'])
        .then(baseKey => {
            return crypto.subtle.deriveBits({
                name: 'PBKDF2',
                salt: salt,
                iterations: iterations,
                hash: 'SHA-256'
            }, baseKey, keyLength * 8);
        })
        .then(derivedBits => new Uint8Array(derivedBits));
}

        async function sha256(message) {
            const encoder = new TextEncoder();
            const data = encoder.encode(message);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            return new Uint8Array(hashBuffer);
        }

        async function getKeyAndNonce(keyInput, nonceInput) {
            return {
                key: new TextEncoder().encode(keyInput).slice(0, 32),
                nonce: new TextEncoder().encode(nonceInput).slice(0, 24)
            };
        }

        function stringToUint8Array(str, format) {
            switch (format) {
                case 'utf8':
                    return new TextEncoder().encode(str);
                case 'hex':
                    return hexToUint8Array(str);
                case 'base32':
                    return base32ToUint8Array(str);
                case 'base64':
                    return base64ToUint8Array(str);
                default:
                    return new Uint8Array();
            }
        }

        function uint8ArrayToString(arr) {
            return new TextDecoder().decode(arr);
        }

        function uint8ArrayToHex(arr) {
            return Array.from(arr).map(b => ('0' + b.toString(16)).slice(-2)).join('');
        }

        function hexToUint8Array(hex) {
            const arr = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                arr[i / 2] = parseInt(hex.substr(i, 2), 16);
            }
            return arr;
        }

        function base32ToUint8Array(base32) {
            const base32Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
            const output = [];
            let value = 0;
            let bitsLength = 0;

            for (const char of base32) {
                const index = base32Alphabet.indexOf(char);
                if (index === -1) continue;

                value = (value << 5) | index;
                bitsLength += 5;

                while (bitsLength >= 8) {
                    output.push((value >> (bitsLength - 8)) & 0xff);
                    bitsLength -= 8;
                }
            }
            return new Uint8Array(output);
        }

        function base64ToUint8Array(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes;
        }

        function uint8ArrayToBase32(arr) {
            const base32Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
            let output = '';
            let bits = 0;
            let value = 0;

            for (const byte of arr) {
                value = (value << 8) | byte;
                bits += 8;

                while (bits >= 5) {
                    output += base32Alphabet[(value >> (bits - 5)) & 0x1f];
                    bits -= 5;
                }
            }

            if (bits > 0) {
                output += base32Alphabet[(value << (5 - bits)) & 0x1f];
            }
            return output;
        }

        function uint8ArrayToBase64(arr) {
            let binary = '';
            const len = arr.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(arr[i]);
            }
            return btoa(binary);
        }
        function updateCounter(counterId, text, format) {
            const counterElement = document.getElementById(counterId);
            const characterCount = text.length;

            let bitCount;
            switch (format) {
                case 'utf8':
                    bitCount = characterCount * 8; // 1 karakter = 8 bit
                    break;
                case 'hex':
                    bitCount = characterCount * 4; // 1 hex = 4 bit
                    break;
                case 'base32':
                    bitCount = characterCount * 5; // 5 bit per karakter, dibagi 8 untuk mendapatkan byte
                    break;
                case 'base64':
                    bitCount = characterCount * 6; // 6 bit per karakter, dibagi 8 untuk mendapatkan byte
                    break;
                default:
                    bitCount = characterCount * 8; // Default ke UTF-8
                }

            counterElement.textContent = `Karakter: ${characterCount} | Ukuran: ${bitCount.toFixed(0)} Bit`;
        }
    
        function togglePassword(id) {
            const input = document.getElementById(id);
            input.type = input.type === 'password' ? 'text' : 'password';
        }

        function clearText(textareaId, counterId, statusId, outputCounterId) {
            document.getElementById(textareaId).value = '';
            document.getElementById(counterId).textContent = 'Karakter: 0 | Ukuran: 0 Bit';
            document.getElementById(statusId).textContent = '';
            document.getElementById(outputCounterId).textContent = 'Karakter: 0 | Ukuran: 0 Bit';
        }

        function copyToClipboard(textareaId) {
            const textarea = document.getElementById(textareaId);
            textarea.select();
            document.execCommand('copy');
            alert('Teks telah disalin ke clipboard!');
        }

document.getElementById('encryptForm').addEventListener('submit', async (event) => {
    event.preventDefault();

    const iterations = parseInt(document.getElementById('iterations').value);
    if (isNaN(iterations) || iterations <= 0) {
        document.getElementById('encryptStatus').textContent = 'Jumlah iterasi harus lebih dari 0!';
        return;
    }
    
    document.getElementById('encryptStatus').textContent = 'Memproses...';

    // Menghasilkan salt dan nonce secara acak
    const saltArray = new Uint8Array(32);
    window.crypto.getRandomValues(saltArray);

    const nonceArray = new Uint8Array(24);
    window.crypto.getRandomValues(nonceArray);

    const text = document.getElementById('inputText').value;
    const password = document.getElementById('password').value;

    const { key } = await getKeyAndNonce(password, nonceArray);
    const derivedKey = await pbkdf2(password, saltArray, iterations, 32);

    const message = stringToUint8Array(text, document.getElementById('inputFormatEncrypt').value);
    const box = nacl.secretbox(message, nonceArray, derivedKey);
    const ciphertext = box; // Simpan dalam bentuk Uint8Array

    // Menggabungkan ciphertext, salt, dan nonce dalam format yang sama
    const combinedOutput = new Uint8Array(ciphertext.length + saltArray.length + nonceArray.length + 8); // Tambahkan ruang untuk iterasi
    combinedOutput.set(ciphertext, 0);
    combinedOutput.set(saltArray, ciphertext.length);
    combinedOutput.set(nonceArray, ciphertext.length + saltArray.length);
    
    // Menyimpan iterasi di akhir dalam bentuk Uint32
    new DataView(combinedOutput.buffer).setUint32(combinedOutput.length - 8, iterations, true);

    let output;
    const outputFormat = document.getElementById('outputFormatEncrypt').value;

    switch (outputFormat) {
        case 'hex':
            output = uint8ArrayToHex(combinedOutput);
            break;
        case 'base32':
            output = uint8ArrayToBase32(combinedOutput);
            break;
        case 'base64':
            output = uint8ArrayToBase64(combinedOutput);
            break;
    }

    document.getElementById('outputEncrypt').value = output;
    updateCounter('outputEncryptCounter', output, outputFormat);
    document.getElementById('encryptStatus').textContent = 'Enkripsi berhasil!';
});

document.getElementById('decryptForm').addEventListener('submit', async (event) => {
    event.preventDefault();
    
    document.getElementById('decryptStatus').textContent = 'Memproses...';

    const ciphertext = document.getElementById('inputCiphertext').value;
    const inputFormat = document.getElementById('inputFormatDecrypt').value;

    let decoded;
    switch (inputFormat) {
        case 'hex':
            decoded = hexToUint8Array(ciphertext);
            break;
        case 'base32':
            decoded = base32ToUint8Array(ciphertext);
            break;
        case 'base64':
            decoded = base64ToUint8Array(ciphertext);
            break;
        default:
            document.getElementById('decryptStatus').textContent = 'Format tidak dikenali';
            return;
    }

    // Logika parsing baru
    try {
        const totalLength = decoded.length;

        // Mengambil panjang iterasi (8 byte terakhir)
        const iterations = new DataView(decoded.buffer).getUint32(totalLength - 8, true);

        // Mengambil nonce (24 byte terakhir sebelum iterasi)
        const nonce = decoded.slice(totalLength - 32, totalLength - 8);

        // Mengambil salt (32 byte terakhir sebelum nonce)
        const salt = decoded.slice(totalLength - 64, totalLength - 32);

        // Mengambil pesan terenkripsi (sisa byte)
        const encryptedMessage = decoded.slice(0, totalLength - 64);

        const password = document.getElementById('decPassword').value;
        const derivedKey = await pbkdf2(password, salt, iterations, 32);

        // Log untuk derived key

        const decrypted = nacl.secretbox.open(encryptedMessage, nonce, derivedKey);

        if (!decrypted) {
            document.getElementById('decryptStatus').textContent = 'Dekripsi gagal!';
            return;
        }

        const output = uint8ArrayToString(decrypted);
        document.getElementById('outputDecrypt').value = output;
        document.getElementById('decryptStatus').textContent = 'Dekripsi berhasil!';
    } catch (error) {
        document.getElementById('decryptStatus').textContent = 'Terjadi kesalahan: ' + error.message;
    }
});

function calculateEntropy(password) {
    const length = password.length;
    const charsetSize = 
        (/[A-Z]/.test(password) ? 26 : 0) + // Huruf besar
        (/[a-z]/.test(password) ? 26 : 0) + // Huruf kecil
        (/\d/.test(password) ? 10 : 0) + // Angka
        (/[^A-Za-z0-9]/.test(password) ? 32 : 0); // Karakter khusus

    if (charsetSize === 0 || length === 0) return 0; // Entropi 0 jika tidak ada karakter

    return Math.log2(Math.pow(charsetSize, length)); // Rumus entropi
}
        
function checkPasswordStrength(password) {
    const entropy = calculateEntropy(password);

    if (entropy < 32) return 0;
    if (entropy < 64) return 1;
    if (entropy < 128) return 2;
    if (entropy < 192) return 3;
    if (entropy < 256) return 4;
    return 5;
}

function updatePasswordStrengthMeter(strength) {
    const strengthMeter = document.getElementById('passwordStrength');

    switch (strength) {
        case 0:
            strengthMeter.textContent = 'Kekuatan Password: Sangat Lemah';
            break;
        case 1:
            strengthMeter.textContent = 'Kekuatan Password: Lemah';
            break;
        case 2:
            strengthMeter.textContent = 'Kekuatan Password: Sedang';
            break;
        case 3:
            strengthMeter.textContent = 'Kekuatan Password: Kuat';
            break;
        case 4:
            strengthMeter.textContent = 'Kekuatan Password: Sangat Kuat';
            break;
        case 5:
            strengthMeter.textContent = 'Kekuatan Password: Tak Terpecahkan';
            break;
        default:
            strengthMeter.textContent = '';
    }
}

document.getElementById('password').addEventListener('input', function() {
    const password = this.value;
    const strength = checkPasswordStrength(password);
    updatePasswordStrengthMeter(strength);
    
    const entropy = calculateEntropy(password);
    document.getElementById('passwordEntropy').textContent = `Entropi: ${entropy.toFixed(0)} bit`;
});

    </script>
</body>
</html>
